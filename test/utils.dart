// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

library test_utils;

import 'dart:async';

import 'package:scheduled_test/src/utils.dart';

/// Wraps [input] to provide a timeout. If [input] completes before
/// [milliseconds] have passed, then the return value completes in the same way.
/// However, if [milliseconds] pass before [input] has completed, [onTimeout] is
/// run and its result is passed to [input] (with chaining, if it returns a
/// [Future]).
///
/// Note that timing out will not cancel the asynchronous operation behind
/// [input].
Future timeout(Future input, int milliseconds, onTimeout()) {
  bool completed = false;
  var completer = new Completer();
  var timer = new Timer(milliseconds, (_) {
    completed = true;
    chainToCompleter(new Future.immediate(null).then((_) => onTimeout()),
        completer);
  });
  input.then((value) {
    if (completed) return;
    timer.cancel();
    completer.complete(value);
  }).catchError((e) {
    if (completed) return;
    timer.cancel();
    completer.completeError(e.error, e.stackTrace);
  });
  return completer.future;
}

/// Returns a [Future] that completes after pumping the event queue [times]
/// times. By default, this should pump the event queue enough times to allow
/// any code to run, as long as it's not waiting on some external event.
Future pumpEventQueue([int times=200]) {
  if (times == 0) return new Future.immediate(null);
  return new Future.immediate(null).then((_) => pumpEventQueue(times - 1));
}

/// A class for controlling the relative order of multiple [Future]s. This is an
/// alternative to using [Timer]s to ensure that callbacks run in a given order.
///
/// [Future]s are generated by calling [wait] with a given position. The
/// [Future]s will complete in position order, pumping the event queue
/// thoroughly between each completion and before the first completion.
class Waiter {
  /// The completers for [Future]s returned by [wait]. Conceptually, this is
  /// really a priority queue, but Dart doesn't have such a data type built in.
  /// Since the number of calls to [wait] will be very small, a [Map] is fine.
  final _completers = new Map<int, Completer>();

  /// Whether [_wait] is currently running.
  var _waiting = false;

  /// Returns a [Future] that will complete in [position] order relative to
  /// other [Future]s returned by [wait]. The order of calling [wait] doesn't
  /// matter.
  Future wait(int position) {
    if (_completers.containsKey(position)) {
      throw new StateError("Waiter already has a wait at position $position");
    }

    var completer = new Completer();
    _completers[position] = completer;
    _wait();
    return completer.future;
  }

  /// Pumps the event queue, then completes the [Future] at the lowest position.
  void _wait() {
    if (_waiting) return;
    _waiting = true;
    pumpEventQueue().then((_) {
      _waiting = false;
      var completer = _completers.remove(_completers.keys.min());
      if (!_completers.isEmpty) _wait();
      completer.complete();
    });
  }
}
